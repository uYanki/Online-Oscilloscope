<html lang="en">

<head>
  <meta charset="utf-8" />
  <script src="[[ url_for('static',filename='js/vue.js') ]]"></script>
  <script src="[[ url_for('static',filename='js/jquery.min.js') ]]"></script>
  <script src="[[ url_for('static',filename='js/axios.min.js') ]]"></script>
  <script src="[[ url_for('static',filename='js/echarts.min.js') ]]"></script>
  <script src="[[ url_for('static',filename='js/socket.io.min.js') ]]"></script>
  <link href="[[ url_for('static',filename='css/bootstrap.min.css') ]]" rel="stylesheet" />
  <title>Oscilloscope</title>
</head>

<body>
  <div id="app" class="center-block" style="max-width: 95vw;">
    <h1>
      Online Oscilloscope
      <small><span class="label label-default">v1.0</span></small>
    </h1>
    <hr />

    <div id="container">
      <!-- channel selector -->
      <div id="selector" class="leftpart">
        <!-- filter -->
        <div id="filter">
          <input type="text" class="form-control" placeholder="filter" v-model="keyword" />
        </div>
        <!-- list -->
        <div id="chanlist">
          <ul class="list-group">
            <li class="list-group-item" v-for="channel in filterChannels">
              <!-- channel name -->
              <label class="checkbox-inline"> <input type="checkbox" v-model="channels[channel]['visible']" @change="updateOption()" /> {{channel}} </label>
              <!-- lastest value -->
              <small id="lastestv" class="pull-right"> {{channels[channel]["lastv"]}} </small>
            </li>
          </ul>
        </div>
      </div>
      <!-- data plotter -->
      <div class="rightpart">
        <div id="dataplot"></div>
        <hr>
      </div>
    </div>

    <!-- run or stop -->
    <button v-if="runstate" type="button" class="btn btn-danger btn-float" v-on:click="disconnect()">
      <span class="glyphicon glyphicon-pause" aria-hidden="true"></span>
    </button>
    <button v-else type="button" class="btn btn-success btn-float" v-on:click="connect()">
      <span class="glyphicon glyphicon-play" aria-hidden="true"></span>
    </button>
  </div>

  <style type="text/css">
    * {
      box-sizing: border-box;
    }

    #container {
      height: 80%;
    }

    .leftpart {
      float: left;
      width: 20%;
      height: 100%;

      display: flex;
      flex-direction: column;
    }

    #filter {
      margin-bottom: 20px;
    }

    #chanlist {
      /* 启用滚动 */
      overflow: auto;
      /* 占满剩余高度 */
      flex: 1;
    }

    /* 隐藏滚动条 */
    #chanlist::-webkit-scrollbar {
      width: 0 !important
    }

    .rightpart {
      float: right;
      width: 78%;
    }

    .btn-float {
      position: fixed;
      right: 8vh;
      bottom: 8vh;
      width: 8vh;
      height: 8vh;
      text-align: center;
      padding: 6px 0;
      font-size: 20px;
      border-radius: 4vh;
    }

    #lastestv {
      color: blueviolet;
    }

    #dataplot {
      width: 100%;
      height: 100%;
    }
  </style>

  <script type="text/javascript">
    let app = new Vue({

      el: "#app",

      data: {

        socketaddr: "ws://127.0.0.1:5000/echo",
        runstate: false,

        keyword: "", // for channel selector  
        maxdisplay: 500, // count of displayed values

        channels: [],

      },

      created: function () {
        let that = this;
        // get channel name
        axios.get('/oscilloscope/channels')
          .then(function (response) {
            response.data["channels"].forEach(
              (value, index, array) => {
                // insert key-value, usage -> this.$set(dict,key,value)
                that.$set(that.channels,
                  value, // channel name
                  {
                    'visible': false, // [bool] whether display
                    'values': [], // [num list] channel values
                    'lastv': 0 // [num] lastest value
                  });
              }
            );
            that.updateOption();
          })
          .catch(function (error) {
            console.log(error);
          });
      },

      // usage -> function 'mounted' called after function 'created'
      mounted: function () {
        let that = this;
        // init chart
        that.initChart();
        // dynamically resize chart
        window.onresize = function windowResize() {
          that.chart.resize();
          that.chart.setOption(that.option, true);
        };
        // auto connect socket
        that.connect();
      },

      computed: {
        filterChannels() {
          let that = this;
          return Object.keys(that.channels).filter(item => {
            // case-insensitive
            return item.toLowerCase().indexOf(that.keyword.toLowerCase()) !== -1;
          });
        }
      },

      methods: {
        // Chart
        initChart: function () {
          let that = this;
          // config chart
          that.option = {
            animation: false,
            xAxis: {
              show: false,
              // type: "", // 'time' or 'category'
              data: [],
              splitLine: {
                show: false
              }
            },
            yAxis: {
              type: "value",
              splitLine: {
                show: true,
              }
            },
            legend: {},
            tooltip: {
              trigger: "item", // 'item' or 'axis'

            },
            // enable wheel Zoom
            // dataZoom: [{
            //   type: "inside"
            // }],
            series: [],
          };
          that.chart = echarts.init(document.getElementById("dataplot"));
          that.chart.setOption(that.option);
        },
        updateOption: function () {
          let that = this;
          // clear previous option
          that.option.series = [];
          // display visible channel
          for (let key in that.channels) {
            // key -> channel name
            let channel = that.channels[key];
            if (channel["visible"] === true) {
              that.option.series.push({
                name: key,
                type: "line",
                data: channel["values"].slice(-that.maxdisplay),
                showSymbol: false,
              });
            }
          }
          // refresh chart
          that.chart.setOption(that.option, true); // no merge = true
        },
        appendValues: function (newvalues) {
          let that = this;
          // append values
          for (let key in newvalues) {
            let channel = that.channels[key];
            channel["values"].push(...newvalues[key]);
            channel["lastv"] = channel["values"].slice(-1)[0]; // lastest value
          }
          // refresh chart
          that.updateOption();
        },

        // Socket IO
        connect: function () {
          let that = this;
          // connect to socket ( addr = ws://ip:port/namespace )
          that.socket = io.connect(that.socketaddr, {
            timeout: 300000,
            reconnectionDelayMax: 1000,
            reconnectionDelay: 1000,
          });
          // listen events
          that.socket.on("connect", () => {
            console.log("-> connect data channel");
            that.runstate = true;
          });
          that.socket.on("disconnect", () => {
            console.log("-> disconnect data channel");
            that.runstate = false;
          })
          // receive data
          that.socket.on("append", (res) => {
            that.appendValues(res["data"]);
          });
        },
        disconnect: function () {
          let that = this;
          // disconnect to socket
          that.socket.disconnect();
        },

      },

    });
  </script>
</body>

</html>